import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
import time

# --- 1. PAGE CONFIG ---
st.set_page_config(
    page_title="VIX Spread Terminal",
    page_icon="ğŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- 2. CONFIGURATION ---
CSV_PATH = Path("vix_spread_data.csv")
SPREADS_CONFIG_NAMES = {
    "en": {"Feb 2026": "Feb 2026", "Mar 2026": "Mar 2026"},
    "zh": {"Feb 2026": "2026å¹´2æœˆ", "Mar 2026": "2026å¹´3æœˆ"}
}
# Internal keys must match the prefixes generated by the fetcher script
SPREAD_KEYS = ["Feb 2026", "Mar 2026"]

# --- 3. TRANSLATIONS (Identical to original) ---
TRANSLATIONS = {
    "en": {
        "page_title": "VIX Spread Terminal",
        "header_subtitle": "VIX Bullish Call Spread Monitor",
        "header_title": "Multi-Expiry Terminal",
        "live_data": "STATIC DATA",  # Changed badge text
        "configuration": "Configuration",
        "language": "Language",
        "active_spreads": "Active Spreads",
        "select_expiries": "Select expiries to monitor",
        "data_settings": "Data Settings",
        "historical_lookback": "Historical Lookback",
        "days": "days",
        "refresh": "ğŸ”„ Reload CSV",
        "last_updated": "Last Data Point",
        "long_leg": "Long Leg (C20)",
        "short_leg": "Short Leg (C30)",
        "net_spread": "Net Spread",
        "volume": "Vol",
        "spread_title": "Spread",
        "individual_legs": "Individual Legs",
        "volume_title": "Volume",
        "mean": "Mean",
        "view_daily_log": "ğŸ“ View Data Source",
        "no_file": "âŒ 'vix_spread_data.csv' not found. Run 'vix_data_fetcher.py' first.",
        "select_spread_warning": "Please select at least one spread expiry in the sidebar.",
        "cheap": "CHEAP",
        "expensive": "RICH",
        "fair": "FAIR",
        "valuation_title": "Statistical Value",
        "calc_title": "Calculator: Risk/Reward at Expiration",
        "inputs": "Inputs",
        "entry_price": "Entry Price (Debit)",
        "stats": "Stats",
        "max_profit": "Max Profit",
        "max_risk": "Max Risk",
        "rr_ratio": "R/R Ratio",
        "breakeven": "Breakeven",
        "chart_x": "VIX Spot Price at Expiration",
        "chart_y": "Profit / Loss",
        "dist_title": "Price Distribution (90 Days)",
        "freq": "Frequency",
        "now": "Now",
        "avg": "Avg",
        "be_abbr": "BE",
    },
    "zh": {
        "page_title": "VIXä»·å·®ç»ˆç«¯",
        "header_subtitle": "VIXçœ‹æ¶¨æœŸæƒä»·å·®ç›‘æ§",
        "header_title": "å¤šåˆ°æœŸæ—¥ç»ˆç«¯",
        "live_data": "é™æ€æ•°æ®",
        "configuration": "é…ç½®",
        "language": "è¯­è¨€",
        "active_spreads": "æ´»è·ƒä»·å·®",
        "select_expiries": "é€‰æ‹©è¦ç›‘æ§çš„åˆ°æœŸæ—¥",
        "data_settings": "æ•°æ®è®¾ç½®",
        "historical_lookback": "å†å²å›æº¯",
        "days": "å¤©",
        "refresh": "ğŸ”„ é‡æ–°åŠ è½½CSV",
        "last_updated": "æœ€æ–°æ•°æ®",
        "long_leg": "å¤šå¤´ (C20)",
        "short_leg": "ç©ºå¤´ (C30)",
        "net_spread": "å‡€ä»·å·®",
        "volume": "æˆäº¤é‡",
        "spread_title": "ä»·å·®",
        "individual_legs": "å•è…¿ä»·æ ¼",
        "volume_title": "æˆäº¤é‡",
        "mean": "å‡å€¼",
        "view_daily_log": "ğŸ“ æŸ¥çœ‹æºæ•°æ®",
        "no_file": "âŒ æœªæ‰¾åˆ° 'vix_spread_data.csv'ã€‚è¯·å…ˆè¿è¡Œ 'vix_data_fetcher.py'ã€‚",
        "select_spread_warning": "è¯·åœ¨ä¾§è¾¹æ ä¸­é€‰æ‹©è‡³å°‘ä¸€ä¸ªä»·å·®åˆ°æœŸæ—¥ã€‚",
        "cheap": "ä½ä¼°",
        "expensive": "é«˜ä¼°",
        "fair": "åˆç†",
        "valuation_title": "ç»Ÿè®¡ä¼°å€¼",
        "calc_title": "è®¡ç®—å™¨ï¼šåˆ°æœŸé£é™©/å›æŠ¥",
        "inputs": "è¾“å…¥å‚æ•°",
        "entry_price": "å…¥åœºä»·æ ¼ (å€Ÿæ–¹)",
        "stats": "ç»Ÿè®¡æ•°æ®",
        "max_profit": "æœ€å¤§åˆ©æ¶¦",
        "max_risk": "æœ€å¤§é£é™©",
        "rr_ratio": "ç›ˆäºæ¯”",
        "breakeven": "ä¿æœ¬ç‚¹",
        "chart_x": "åˆ°æœŸæ—¶ VIX ç°è´§ä»·æ ¼",
        "chart_y": "åˆ©æ¶¦ / æŸå¤±",
        "dist_title": "ä»·æ ¼åˆ†å¸ƒ (90å¤©)",
        "freq": "é¢‘ç‡ (å¤©æ•°)",
        "now": "ç°ä»·",
        "avg": "å‡å€¼",
        "be_abbr": "ä¿æœ¬",
    }
}

# --- 4. SESSION STATE ---
if 'language' not in st.session_state:
    st.session_state.language = 'zh'

def t(key):
    return TRANSLATIONS[st.session_state.language].get(key, key)

# --- 5. ADAPTIVE CSS (Identical to original) ---
# --- 5. ADAPTIVE CSS ---
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;600;700&display=swap');
    
    .dashboard-header {
        background: linear-gradient(90deg, rgba(38,166,154,0.12) 0%, transparent 50%);
        border-bottom: 1px solid rgba(38,166,154,0.25);
        padding: 20px 30px;
        margin: -1rem -1rem 2rem -1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .header-title {
        font-family: 'Plus Jakarta Sans', 'Noto Sans SC', sans-serif;
        font-size: 28px;
        font-weight: 700;
        letter-spacing: -0.5px;
    }
    .header-subtitle {
        font-family: 'JetBrains Mono', 'Noto Sans SC', monospace;
        font-size: 12px;
        color: #26a69a;
        letter-spacing: 2px;
        text-transform: uppercase;
    }
    .live-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(38,166,154,0.12);
        border: 1px solid rgba(38,166,154,0.35);
        padding: 8px 16px;
        border-radius: 20px;
        font-family: 'JetBrains Mono', 'Noto Sans SC', monospace;
        font-size: 11px;
        color: #26a69a;
    }
    .live-dot {
        width: 8px;
        height: 8px;
        background: #26a69a;
        border-radius: 50%;
    }
    .metric-card {
        border-radius: 12px;
        padding: 24px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
        border: 1px solid rgba(128, 128, 128, 0.25);
        background: rgba(128, 128, 128, 0.06);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        height: 100%; /* Keeps cards aligned */
    }
    .metric-card:hover {
        transform: translateY(-2px);
        border-color: rgba(38, 166, 154, 0.4);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    }
    .metric-label {
        font-family: 'Plus Jakarta Sans', 'Noto Sans SC', sans-serif;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        text-transform: uppercase;
        margin-bottom: 8px;
        opacity: 0.7;
    }
    .metric-value {
        font-family: 'JetBrains Mono', monospace;
        font-size: 36px;
        font-weight: 700;
        line-height: 1;
    }
    .metric-delta {
        font-family: 'JetBrains Mono', monospace;
        font-size: 13px;
        font-weight: 600;
        margin-top: 8px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border-radius: 6px;
    }
    .delta-positive { color: #26a69a; background: rgba(38,166,154,0.15); }
    .delta-negative { color: #ef5350; background: rgba(239,83,80,0.15); }
    .delta-neutral { color: #9e9e9e; background: rgba(158,158,158,0.15); }
    
    .volume-text {
        font-family: 'JetBrains Mono', 'Noto Sans SC', monospace;
        font-size: 12px;
        margin-top: 8px;
        opacity: 0.7;
    }

    /* --- NEW CSS FOR VALUATION TAGS --- */
    .val-tag {
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 4px;
        margin-top: 12px;
        display: inline-block;
        font-weight: 600;
    }
    .val-cheap { background: rgba(38,166,154,0.2); color: #26a69a; border: 1px solid rgba(38,166,154,0.4); }
    .val-expensive { background: rgba(239,83,80,0.2); color: #ef5350; border: 1px solid rgba(239,83,80,0.4); }
    .val-fair { background: rgba(158,158,158,0.2); color: #bdbdbd; border: 1px solid rgba(158,158,158,0.4); }
</style>
""", unsafe_allow_html=True)

# --- 6. DATA LOADER ---
@st.cache_data
def load_data(csv_path):
    if not csv_path.exists():
        return None
    try:
        df = pd.read_csv(csv_path)
        
        # 1. Ensure Date is datetime
        df["Date"] = pd.to_datetime(df["Date"])
        df = df.sort_values("Date")
        
        # 2. FORCE NUMERIC CONVERSION [CRITICAL FIX]
        # This converts any "text numbers" into real numbers for the chart
        cols_to_convert = [c for c in df.columns if c != "Date"]
        for col in cols_to_convert:
            df[col] = pd.to_numeric(df[col], errors='coerce')
            
        return df
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None

# --- NEW ANALYTICS HELPER ---
def calculate_valuation(series: pd.Series, current_value: float):
    """Calculates Z-Score and Percentile Rank for the current value."""
    # Need at least 5 data points to make a meaningful calculation
    if series.empty or len(series) < 5:
        return 0.0, 50.0
        
    # Z-Score: (Value - Mean) / Standard Deviation
    mean = series.mean()
    std = series.std()
    z_score = (current_value - mean) / std if std != 0 else 0
    
    # Percentile Rank: What % of historical data is below current price?
    percentile = (series < current_value).mean() * 100
    
    return z_score, percentile

# --- 7. CHART FUNCTION ---
def create_spread_chart(df: pd.DataFrame, spread_name: str, lang: str):
    prefix = spread_name.replace(" ", "_")
    
    # Check if columns exist
    if f"{prefix}_Spread" not in df.columns:
        return go.Figure()

    # Prep Plot Data
    plot_df = pd.DataFrame(index=df["Date"])
    
    # --- FIX: ADD .values HERE ---
    # We use .values to ignore index alignment issues
    plot_df["Spread"] = df[f"{prefix}_Spread"].values
    plot_df["Long"] = df[f"{prefix}_Long_Price"].values
    plot_df["Short"] = df[f"{prefix}_Short_Price"].values
    plot_df["Volume"] = df[f"{prefix}_Total_Volume"].values
    
    # Force ensure numeric (just in case)
    plot_df = plot_df.apply(pd.to_numeric, errors='coerce')
    
    has_volume = plot_df["Volume"].sum() > 0

    spread_label = TRANSLATIONS[lang]["spread_title"]
    legs_label = TRANSLATIONS[lang]["individual_legs"]
    volume_label = TRANSLATIONS[lang]["volume_title"]
    mean_label = TRANSLATIONS[lang]["mean"]
    display_name = SPREADS_CONFIG_NAMES[lang].get(spread_name, spread_name)

    # Subplots
    if has_volume:
        fig = make_subplots(
            rows=3, cols=1,
            row_heights=[0.5, 0.25, 0.25],
            shared_xaxes=True,
            vertical_spacing=0.08,
            subplot_titles=(f"{display_name} {spread_label}", legs_label, volume_label)
        )
    else:
        fig = make_subplots(
            rows=2, cols=1,
            row_heights=[0.6, 0.4],
            shared_xaxes=True,
            vertical_spacing=0.1,
            subplot_titles=(f"{display_name} {spread_label}", legs_label)
        )

    # 1. Spread Trace
    fig.add_trace(go.Scatter(
        x=plot_df.index, y=plot_df["Spread"],
        mode='lines', name=spread_label,
        line=dict(color='#26a69a', width=2.5),
        fill='tozeroy', fillcolor='rgba(38,166,154,0.15)',
        hovertemplate=f'<b>{spread_label}</b>: %{{y:.2f}}<extra></extra>'
    ), row=1, col=1)

    # Mean Line
    mean_val = plot_df["Spread"].mean()
    fig.add_hline(y=mean_val, line_dash="dash", line_color="#9e9e9e",
                 annotation_text=f"{mean_label}: {mean_val:.2f}", row=1, col=1)

    # 2. Legs Traces
    fig.add_trace(go.Scatter(
        x=plot_df.index, y=plot_df["Long"], mode='lines', name='C20 (Long)',
        line=dict(color='#42a5f5', width=1.5)
    ), row=2, col=1)
    
    fig.add_trace(go.Scatter(
        x=plot_df.index, y=plot_df["Short"], mode='lines', name='C30 (Short)',
        line=dict(color='#ab47bc', width=1.5)
    ), row=2, col=1)

    # 3. Volume Trace
    if has_volume:
        fig.add_trace(go.Bar(
            x=plot_df.index, y=plot_df["Volume"], name=volume_label,
            marker_color='rgba(38,166,154,0.5)'
        ), row=3, col=1)

    # Layout
    fig.update_layout(
        height=550 if has_volume else 450,
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(family="JetBrains Mono, Noto Sans SC, monospace", size=11),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1, bgcolor='rgba(0,0,0,0)'),
        margin=dict(l=60, r=30, t=80, b=50),
        hovermode='x unified',
        showlegend=True
    )
    fig.update_xaxes(gridcolor='rgba(128,128,128,0.2)', showgrid=True, zeroline=False)
    fig.update_yaxes(gridcolor='rgba(128,128,128,0.2)', showgrid=True, zeroline=False)
    
    return fig

# HISTOGRAM FUNCTION ---
def create_distribution_chart(df, prefix, current_val, lang):
    spread_data = df[f"{prefix}_Spread"].dropna()
    mean_val = spread_data.mean()
    
    fig = go.Figure()
    fig.add_trace(go.Histogram(
        x=spread_data, name='History', nbinsx=25,
        marker_color='rgba(128, 128, 128, 0.3)', marker_line_color='rgba(128, 128, 128, 0.5)', marker_line_width=1
    ))
    
    # Current Price Line
    fig.add_vline(x=current_val, line_width=3, line_color="#26a69a" if current_val < mean_val else "#ef5350")
    
    # Mean Line
    fig.add_vline(x=mean_val, line_dash="dash", line_width=1, line_color="#ffa726")
    avg_text = TRANSLATIONS[lang]["avg"]
    fig.add_annotation(x=mean_val, y=1.02, yref="paper", text=f"{avg_text}: {mean_val:.2f}", showarrow=False, font=dict(color="#ffa726", size=10))

    now_text = TRANSLATIONS[lang]["now"]
    fig.add_annotation(x=current_val, y=0.9, yref="paper", text=f"{now_text}: {current_val:.2f}", showarrow=True, arrowhead=2, ax=0, ay=-20, font=dict(color="#ffffff", size=12), bgcolor="rgba(0,0,0,0.6)")

    fig.update_layout(
        # CHANGED: Removed title (we will add it in Streamlit for better alignment)
        # CHANGED: Increased height from 300 to 380 to match right column
        height=380, 
        margin=dict(l=20, r=20, t=20, b=20), # Reduced top margin since title is gone
        plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)', 
        font=dict(family="JetBrains Mono, monospace", size=11), 
        xaxis_title=TRANSLATIONS[lang]["spread_title"], 
        yaxis_title=TRANSLATIONS[lang]["freq"], 
        showlegend=False, bargap=0.05
    )
    fig.update_xaxes(gridcolor='rgba(128,128,128,0.2)')
    fig.update_yaxes(gridcolor='rgba(128,128,128,0.2)')
    return fig

# --- NEW: PAYOFF CALCULATOR CHART ---
def create_payoff_chart(entry_price, lang):
    # Hardcoded strikes based on your tickers (C20 / C30)
    K1 = 20
    K2 = 30
    
    # Generate Spot VIX range
    spot_prices = list(range(10, 50, 1))
    pnl = []
    
    for s in spot_prices:
        val_long = max(s - K1, 0)
        val_short = max(s - K2, 0)
        spread_val = val_long - val_short
        profit = spread_val - entry_price
        pnl.append(profit)
        
    fig = go.Figure()
    
    # Add P&L Line
    fig.add_trace(go.Scatter(
        x=spot_prices, y=pnl,
        mode='lines', name='P&L',
        line=dict(color='#ffffff', width=2),
        fill='tozeroy', 
        fillcolor='rgba(255, 255, 255, 0.1)'
    ))

    # Add Zero Line
    fig.add_hline(y=0, line_dash="solid", line_color="#9e9e9e", line_width=1)
    
    # Metrics for Title
    max_profit = (K2 - K1) - entry_price
    max_loss = -entry_price
    breakeven = K1 + entry_price
    
    # --- TRANSLATION LOGIC ---
    # We grab the translated words based on 'lang' (en or zh)
    t_profit = TRANSLATIONS[lang]["max_profit"]
    t_loss = TRANSLATIONS[lang]["max_risk"]
    t_x = TRANSLATIONS[lang]["chart_x"]
    t_y = TRANSLATIONS[lang]["chart_y"]
    
    # Annotations
    be_text = TRANSLATIONS[lang]["be_abbr"]
    fig.add_vline(x=breakeven, line_dash="dash", line_color="#ffa726", 
                  annotation_text=f"{be_text}: {breakeven:.2f}", annotation_position="top left")

    fig.update_layout(
        # Use the translated variables here
        title=dict(text=f"{t_profit}: +{max_profit:.2f} | {t_loss}: {max_loss:.2f}", font=dict(size=14)),
        height=300,
        margin=dict(l=20, r=20, t=40, b=20),
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        xaxis_title=t_x, # Translated X-Axis
        yaxis_title=t_y, # Translated Y-Axis
        font=dict(family="JetBrains Mono, monospace", size=11),
        hovermode="x unified"
    )
    
    # Color areas
    fig.add_shape(type="rect", x0=10, y0=0, x1=50, y1=15, 
                  fillcolor="rgba(38,166,154,0.1)", layer="below", line_width=0)
    fig.add_shape(type="rect", x0=10, y0=-15, x1=50, y1=0, 
                  fillcolor="rgba(239,83,80,0.1)", layer="below", line_width=0)

    return fig

# --- 8. SIDEBAR ---
with st.sidebar:
    st.markdown(f"## âš™ï¸ {t('configuration')}")
    st.markdown("---")
    
    # Language
    st.markdown(f"**{t('language')}**")
    if st.session_state.language == 'en':
        if st.button("ä¸­æ–‡", key='lang_zh'):
            st.session_state.language = 'zh'
            st.rerun()
    else:
        if st.button("English", key='lang_en'):
            st.session_state.language = 'en'
            st.rerun()
    
    st.markdown("---")
    st.markdown(f"### {t('active_spreads')}")
    
    # Spread Selection
    spread_display_names = [SPREADS_CONFIG_NAMES[st.session_state.language][s] for s in SPREAD_KEYS]
    selected_display = st.multiselect(
        t('select_expiries'),
        options=spread_display_names,
        default=spread_display_names
    )
    # Map back to internal keys
    display_map = {v: k for k, v in SPREADS_CONFIG_NAMES[st.session_state.language].items()}
    active_spreads = [display_map[d] for d in selected_display]
    
    st.markdown("---")
    st.markdown(f"### {t('data_settings')}")
    
    lookback_days = st.selectbox(
        t('historical_lookback'),
        options=[30, 60, 90, 180, 365, 9999],
        index=2,
        format_func=lambda x: f"{x} {t('days')}" if x < 9999 else "All"
    )
    
    st.markdown("---")
    
    # Simple Manual Refresh Button
    if st.button(t('refresh'), width='stretch'):
        # Clear cache to force a re-read of the CSV file
        st.cache_data.clear()
        st.rerun()

# --- 9. MAIN DASHBOARD ---
st.markdown(f"""
<div class="dashboard-header">
    <div>
        <div class="header-subtitle">{t('header_subtitle')}</div>
        <div class="header-title">{t('header_title')}</div>
    </div>
    <div class="live-badge">
        <div class="live-dot"></div>
        {t('live_data')}
    </div>
</div>
""", unsafe_allow_html=True)

if not active_spreads:
    st.warning(t('select_spread_warning'))
    st.stop()

# --- LOAD DATA ---
full_df = load_data(CSV_PATH)

if full_df is None or full_df.empty:
    st.error(t('no_file'))
    st.stop()

# Filter by lookback
if lookback_days < 9999:
    cutoff = pd.Timestamp.now() - pd.Timedelta(days=lookback_days)
    df_chart = full_df[full_df["Date"] >= cutoff]
else:
    df_chart = full_df

# Get Last Row and Prev Row for Metrics
latest = full_df.iloc[-1]
prev = full_df.iloc[-2] if len(full_df) > 1 else latest

st.caption(f"{t('last_updated')}: {latest['Date'].strftime('%Y-%m-%d')}")

# --- TABS & METRICS ---
tab_names = [SPREADS_CONFIG_NAMES[st.session_state.language][s] for s in active_spreads]
tabs = st.tabs(tab_names)

# [REPLACE THE ENTIRE MAIN LOOP WITH THIS]
for tab, spread_name in zip(tabs, active_spreads):
    with tab:
        prefix = spread_name.replace(" ", "_")
        
        # 1. PREPARE DATA
        def get_val(row, key, default=0.0):
            val = row.get(key, default)
            return 0.0 if pd.isna(val) else val
            
        cur_long = get_val(latest, f"{prefix}_Long_Price")
        cur_short = get_val(latest, f"{prefix}_Short_Price")
        cur_spread = get_val(latest, f"{prefix}_Spread")
        cur_l_vol = get_val(latest, f"{prefix}_Long_Volume")
        cur_s_vol = get_val(latest, f"{prefix}_Short_Volume")
        
        prev_long = get_val(prev, f"{prefix}_Long_Price")
        prev_short = get_val(prev, f"{prefix}_Short_Price")
        prev_spread = get_val(prev, f"{prefix}_Spread")
        
        d_long = cur_long - prev_long
        d_short = cur_short - prev_short
        d_spread = cur_spread - prev_spread
        
        # Calculate Valuation
        spread_history = df_chart[f"{prefix}_Spread"].dropna()
        z_score, percentile = calculate_valuation(spread_history, cur_spread)

        # 2. RENDER METRICS (3 COLUMNS)
        c1, c2, c3 = st.columns(3)
        
        def render_metric(col, label, val, delta, vol=None):
            delta_cls = "positive" if delta > 0 else "negative" if delta < 0 else "neutral"
            sign = "+" if delta > 0 else ""
            arrow = "â–²" if delta > 0 else "â–¼" if delta < 0 else "âˆ’"
            
            html = [
                '<div class="metric-card">',
                f'<div class="metric-label">{label}</div>',
                f'<div class="metric-value">{val:.2f}</div>',
                f'<div class="metric-delta delta-{delta_cls}">{arrow} {sign}{delta:.2f}</div>'
            ]
            if vol is not None:
                html.append(f'<div class="volume-text">{t("volume")}: {int(vol):,}</div>')
            else:
                html.append('<div class="volume-text">&nbsp;</div>')
            html.append('</div>')
            col.markdown("".join(html), unsafe_allow_html=True)
            
        render_metric(c1, t('long_leg'), cur_long, d_long, cur_l_vol)
        render_metric(c2, t('short_leg'), cur_short, d_short, cur_s_vol)
        render_metric(c3, t('net_spread'), cur_spread, d_spread)
        
        # 3. VALUATION LINE
        if z_score <= -1.0: status = t('cheap')
        elif z_score >= 1.0: status = t('expensive')
        else: status = t('fair')
            
        st.markdown(f"""
        <div style="text-align: left; margin-top: 8px; margin-bottom: 2px;">
            <span class="volume-text">
                {t('valuation_title')}: <b>{status}</b> (Z-score: {z_score:.1f}Ïƒ | Percentile: {int(percentile)}%)
            </span>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown("---")
        
        # 4. CHART
        fig = create_spread_chart(df_chart, spread_name, st.session_state.language)
        
        # --- FIX IS HERE: ADDED UNIQUE KEY ---
        st.plotly_chart(fig, width='stretch', theme="streamlit", key=f"main_chart_{prefix}")


        # --- ANALYTICS SECTION ---
        with st.expander(f"ğŸ“Š {t('valuation_title')} & {t('calc_title')}"):
            col_hist, col_calc = st.columns(2)
            
            # --- LEFT COLUMN: HISTOGRAM ---
            with col_hist:
                # [NEW] Add header here to match the right side alignment
                st.markdown(f"**{t('dist_title')}**")
                
                hist_fig = create_distribution_chart(df_chart, prefix, cur_spread, st.session_state.language)
                st.plotly_chart(hist_fig, use_container_width=True, key=f"hist_{prefix}")

            # --- RIGHT COLUMN: CALCULATOR ---
            with col_calc:
                st.markdown(f"**{t('calc_title')}**")
                
                # Inputs
                c_in1, c_in2 = st.columns([1, 1])
                with c_in1:
                    sim_entry = st.number_input(
                        t('entry_price'), 
                        min_value=0.0, max_value=10.0, 
                        value=float(cur_spread), step=0.05, format="%.2f", 
                        key=f"sim_{prefix}"
                    )
                
                # Math
                spread_width = 10.0
                max_profit = spread_width - sim_entry
                max_loss = sim_entry
                rr_ratio = max_profit / max_loss if max_loss > 0 else 0
                breakeven = 20 + sim_entry

                # Stats display
                st.caption(f"{t('max_profit')}: **{max_profit:.2f}** | {t('max_risk')}: **{max_loss:.2f}**")
                st.caption(f"{t('rr_ratio')}: **1 : {rr_ratio:.1f}** | {t('breakeven')}: **{breakeven:.2f}**")
                
                # Payoff Chart
                payoff_fig = create_payoff_chart(sim_entry, st.session_state.language)
                payoff_fig.update_layout(height=220, margin=dict(t=30, b=20))
                st.plotly_chart(payoff_fig, use_container_width=True, key=f"payoff_{prefix}")

# --- DATA TABLE ---
st.markdown("---")
with st.expander(t('view_daily_log'), expanded=False):
    st.dataframe(full_df.sort_values("Date", ascending=False), width='stretch')

